# natto導入 ~MecabをRuby/Railsから呼ぶ技術検証（Docker / Debian slim）

## 目的
- Rails から MeCab を natto 経由で呼べる状態にする
- 開発環境（docker-compose.dev.yml）で動作確認できること
- 参照している辞書パスを取得できること（辞書切替の前提確認）

## 結論
- `gem "natto"` を追加して `bundle install` すれば、Rails（runner）から MeCab を呼べる
- 動作確認で、`Natto::MeCab#parse` で解析結果が返ること、`nm.dicts / readlink` で辞書パスが取得できることを確認した

## 変更点
- Gemfile に `natto` を追加
- natto 導入後の動作確認手順をdoc化

## 手順

### 1. 前提確認（natto導入要件）
コンテナ内で以下を実行。

```bash
mecab -v
mecab-config --libs
mecab-config --cflags
```
出力例（--libs）
```bash
$ mecab -v
mecab of 0.996   #必要バージョン
$ mecab-config --libs
-L/usr/lib/x86_64-linux-gnu -lmecab -lstdc++
$ mecab-config --cflags

```
（`mecab-config --cflags`は追加の include指定が不要な構成だと空白行になることがある）

- `mecab-config --libs`：MeCab をリンクするためのオプションを表示する（結果として、ライブラリ情報が取得できる状態か確認できる）
- `-L/usr/lib/x86_64-linux-gnu`：ライブラリ探索パス
- `-lmecab`：libmecab.so（共有ライブラリ）を使うという宣言
- `-lstdc++`：C++ 標準ライブラリも必要という宣言
---

- `mecab-config --cflags`：コンパイル時のオプション（includeパス等）を表示する

※ 何も表示されないケースもある（追加指定が不要な構成など）

=>両方ともとりあえずエラーがでなければOK

---
#### 自分の理解のための補足 -ここでいう`リンクとコンパイル`について
- MeCab をソースからビルドするなら C++ コンパイラが必要

- C/C++といったコンパイル方式の言語は**コンパイルとリンク**が必要
- `コンパイル`: ソースコード → オブジェクトコード（部品）
- `リンク`: オブジェクトコード + ライブラリ → 実行ファイル（完成品）

これら一連の作業(コンパイル=>リンク)は`ビルド (Build) `と呼ばれ、開発ツール（GCC, Clangなど）が自動的に実行してくれることがほとんど。

 ↓の3.3. 動的リンク（dynamic linking）が今回の接続の方式??<br>
参考:
https://kamino.hatenablog.com/entry/c%2B%2B-principle-of-build-library

ざっくり理解でかなり不明点も多いが、開発の本筋からずれるので深堀はここまで

コンパイル方式の言語を取り扱う時に再学習すること

---

### 2. natto を導入（Gemfile）
- Gemfile に追記
```Gemfile
# MeCabライブラリをRubyのコードから使えるようにするラッパー
gem "natto"
```

- インストール
```bash
make exec
$ bundle install
exit
make down
make dev-build-nocache
```

### 3. 動作確認

  1) Ruby から natto が読めて MeCab に接続できるか（version）

      期待：MeCabのバージョンが表示される
      ```bash
      make exec
      $ bundle exec ruby -e 'require "natto"; puts Natto::MeCab.new.version'
      0.996
      ```

  2) Ruby から解析できるか（parse）

      ```bash
      $ bundle exec ruby -e 'require "natto"; nm=Natto::MeCab.new; puts nm.parse("改善の余地はあるさ。")'
      ```

      期待：形態素解析結果が複数行で表示される

      ```bash
      改善    名詞,サ変接続,*,*,*,*,改善,カイゼン,カイゼン
      の      助詞,連体化,*,*,*,*,の,ノ,ノ
      余地    名詞,一般,*,*,*,*,余地,ヨチ,ヨチ
      は      助詞,係助詞,*,*,*,*,は,ハ,ワ
      ある    動詞,自立,*,*,五段・ラ行,基本形,ある,アル,アル
      さ      助詞,終助詞,*,*,*,*,さ,サ,サ
      。      記号,句点,*,*,*,*,。,。,。
      EOS
      ```

  3) Rails 環境で動くか（runner）
      ```bash
      $ bin/rails runner 'require "natto"; nm=Natto::MeCab.new; puts nm.parse("改善 の余地はあるさ。"); p nm.dicts.map(&:filepath)'
      $ readlink -f /var/lib/mecab/dic/debian/sys.dic
      ```
      期待：形態素解析結果が複数行で表示される

      ```bash
      改善    名詞,サ変接続,*,*,*,*,改善,カイゼン,カイゼン
      の      助詞,連体化,*,*,*,*,の,ノ,ノ
      余地    名詞,一般,*,*,*,*,余地,ヨチ,ヨチ
      は      助詞,係助詞,*,*,*,*,は,ハ,ワ
      ある    動詞,自立,*,*,五段・ラ行,基本形,ある,アル,アル
      さ      助詞,終助詞,*,*,*,*,さ,サ,サ
      。      記号,句点,*,*,*,*,。,。,。
      EOS
      ["/var/lib/mecab/dic/debian/sys.dic"]
      ```
  4) 参照辞書の実体確認
      ```bash
      # 辞書情報の確認
      $ mecab -D
      # 辞書名の確認
      $ readlink -f /var/lib/mecab/dic/debian/sys.dic
      ```
      期待：辞書情報と辞書パスが表示される
      ```bash
      filename:       /var/lib/mecab/dic/debian/sys.dic #mecab -D が示す現在の辞書ファイル
      version:        102
      charset:        UTF-8
      type:   0
      size:   392127
      left size:      1316
      right size:     1316

      /var/lib/mecab/dic/ipadic-utf8/sys.dic #辞書名確認
      ```
      補足: `readlink -f` は **パスを正規化して絶対パスを返す**（途中にシンボリックリンクがあれば解決して最終到達先を返す）。


参考:
  - natto（GitHub）: https://github.com/buruzaemon/natto

  - Zenn: https://zenn.dev/ndjndj/articles/5f58caadc264ef

  - MeCab公式: https://taku910.github.io/mecab/


### 開発メモ: bundler の PermissionError が出た場合
非root実行（--user UID:GID）でコンテナを動かしている場合、/usr/local/bundle に書き込めず失敗することがある。

エラー例
```
Bundler::PermissionError There was an error while trying to write to `/usr/local/bundle/cache/...`
```

下記、いずれかの対応をする。

1)恒久対応: Dockerfile 側で /usr/local/bundle の権限を調整
```Dockerfile
# Bundlerの保存先を確保（非root実行でも書けるようにする）
RUN mkdir -p /usr/local/bundle \
    && chown -R 1000:1000 /usr/local/bundle

ENV BUNDLE_PATH=/usr/local/bundle
```

2)一時対応策: コマンドでBundlerの保存先を確保
```bash
make exec
bundle config set --local path vendor/bundle
bundle install
```
